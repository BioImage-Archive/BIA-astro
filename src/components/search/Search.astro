---
import StudyCard from '../../components/cards/BrowseStudyCard.astro';
import ImageCard from '../../components/cards/BrowseImageCard.astro';
import SearchFacet from './SearchFacet.astro';
import SearchSelectedFacet from './SearchSelectedFacet.astro';
import PaginationControl from '../PaginationControl.astro';
import  "../../styles/toggle.css"
import "../../styles/browse_controls.css"
import "../../styles/filter_cards.css"
import { generateParamString } from "../SharedJSFunctions.js"
import {type SelectedFacets, type SearchHits, type FacetData, type PaginationData} from "./SearchInterface.astro"
import { PUBLIC_SEARCH_API } from "astro:env/client";

const { url, query, searchType} =
  Astro.props as {
    url: URL;
    query: string;
    searchType: string;
  };

const searchEndpoint = searchType === "study"? `${PUBLIC_SEARCH_API}/search/fts`: `${PUBLIC_SEARCH_API}/search/fts/image`;
const searchPageURL = searchType === "study"? "/bioimage-archive/studies": "/bioimage-archive/images";
const sortBy = url.searchParams.get('sortBy');
const sortOrder = url.searchParams.get('sortOrder');
const page = Number(url.searchParams.get('pagination.page')) || 1;

const selectedFacets: SelectedFacets = {
  "facet.organism": url.searchParams.getAll("facet.organism"),
  "facet.imaging_method": url.searchParams.getAll("facet.imaging_method"),
  "facet.year": url.searchParams.getAll("facet.year"),

  "facet.image_format": url.searchParams.getAll("facet.image_format"),
  "size_c.eq": url.searchParams.getAll("size_c.eq"),

  // NEW: range filters (store as single-value arrays for compatibility)
  "size_x.gte": url.searchParams.getAll("size_x.gte"),
  "size_x.lte": url.searchParams.getAll("size_x.lte"),

  "size_y.gte": url.searchParams.getAll("size_y.gte"),
  "size_y.lte": url.searchParams.getAll("size_y.lte"),

  "size_z.gte": url.searchParams.getAll("size_z.gte"),
  "size_z.lte": url.searchParams.getAll("size_z.lte"),


  "size_t.gte": url.searchParams.getAll("size_t.gte"),
  "size_t.lte": url.searchParams.getAll("size_t.lte"),

  "total_size_in_bytes.gte": url.searchParams.getAll("total_size_in_bytes.gte"),
  "total_size_in_bytes.lte": url.searchParams.getAll("total_size_in_bytes.lte"),

  "total_physical_size_x.gte": url.searchParams.getAll("total_physical_size_x.gte"),
  "total_physical_size_x.lte": url.searchParams.getAll("total_physical_size_x.lte"),

  "total_physical_size_y.gte": url.searchParams.getAll("total_physical_size_y.gte"),
  "total_physical_size_y.lte": url.searchParams.getAll("total_physical_size_y.lte"),

  "total_physical_size_z.gte": url.searchParams.getAll("total_physical_size_z.gte"),
  "total_physical_size_z.lte": url.searchParams.getAll("total_physical_size_z.lte"),
};

let hits = {} as SearchHits;
let facetData = {} as FacetData;
let paginationData = {} as PaginationData;


if (query || query === "") {
  const searchURL = generateParamString(
    searchEndpoint,
    query,
    page,
    selectedFacets
  );

  const res = await fetch(searchURL);
  if (res.ok) {
    const data = await res.json();
    hits = data.hits;
    facetData = data.facets;
    paginationData = data.pagination;
  }
}


const totalResults = hits.total.value;
let results;

// Sorting on Server side till the API can sort results.

function parseAccession(id) {
    const match = id.match(/^([A-Z\-]+)(\d+)$/i);
    if (!match) return [id, 0];
    return [match[1], parseInt(match[2], 10)];
  }

function sortAcession(aId, bId, sortOrder){
  const [aPrefix, aNum] = parseAccession(aId);
      const [bPrefix, bNum] = parseAccession(bId);
      const prefixCompare = aPrefix.localeCompare(bPrefix);
      if (prefixCompare !== 0) return sortOrder === 'descending' ? -prefixCompare : prefixCompare;
      return sortOrder === 'descending' ? bNum - aNum : aNum - bNum;
}

function sortReleaseDate(aReleaseDate, bReleaseDate, sortOrder){
  const aTime = new Date(aReleaseDate).getTime();
  const bTime = new Date(bReleaseDate).getTime();
  return sortOrder === 'descending' ? bTime - aTime : aTime - bTime
}

switch(sortBy) {
  // case "relevance":
  //   results = sortOrder === "descending"? hits.hits.reverse() : hits.hits;
  //   break;
  // case "accession":
  //   results = hits.hits.sort((a, b) => {return sortAcession(a?._source?.accession_id, b?._source?.accession_id, sortOrder)});
  //   break;
  // case "release_date":
  //   results = hits.hits.sort(function(a,b){ return sortReleaseDate(a?._source?.release_date, b?._source?.release_date, sortOrder)});
  //   break;
  default:
    results = hits.hits;
    break;
}

function hasBuckets(x: any): x is FacetData {
  return !!x && Array.isArray(x.buckets);
}

function hasMinMax(x: any): x is { min: number; max: number } {
  return !!x && typeof x.min === "number" && typeof x.max === "number";
}


function handleRangeFilters(){

}

const FACET_CONFIG: Record<
  string,
  { title: string; type: "terms" | "range"; queryKey?: string; field?: string }
> = {
  scientific_name: { title: "Organism", type: "terms", queryKey: "facet.organism" },
  imaging_method: { title: "Imaging Method", type: "terms", queryKey: "facet.imaging_method" },
  release_date: { title: "Release Year", type: "terms", queryKey: "facet.year" },

  image_format: { title: "Image Format", type: "terms", queryKey: "facet.image_format" },
  number_of_channels: { title: "Channels", type: "terms", queryKey: "size_c.eq" },

  z_planes: { title: "Z-Planes", type: "range", field: "size_z" },
  image_pixel_x: { title: "Image Pixel X", type: "range", field: "size_x" },
  image_pixel_y: { title: "Image Pixel Y", type: "range", field: "size_y" },
  time_steps: { title: "Time Steps", type: "range", field: "size_t" },
  total_size_in_bytes: { title: "Total Size (bytes)", type: "range", field: "total_size_in_bytes" },
  total_physical_size_x: { title: "Physical Size X", type: "range", field: "total_physical_size_x" },
  total_physical_size_y: { title: "Physical Size Y", type: "range", field: "total_physical_size_y" },
  total_physical_size_z: { title: "Physical Size Z", type: "range", field: "total_physical_size_z" },
};

const facets = Object.entries(facetData).reduce((acc, [facetKey, data]) => {
  const cfg = FACET_CONFIG[facetKey];
  if (!cfg) return acc;

  // TERMS FACETS (buckets)
  if (cfg.type === "terms") {
    if (!hasBuckets(data)) return acc;

    const valuesAndCounts = data.buckets
      .slice()
      .sort((a, b) => {
        const aKey = (a.key_as_string ?? a.key ?? "").toString().toLowerCase();
        const bKey = (b.key_as_string ?? b.key ?? "").toString().toLowerCase();
        return aKey.localeCompare(bKey);
      })
      .reduce((obj, bucket) => {
        const k = (bucket.key_as_string ?? bucket.key ?? "").toString();
        obj[k] = bucket.doc_count;
        return obj;
      }, {} as Record<string, number>);

    const totalFacetCounts =
      Object.keys(valuesAndCounts).length + (data.sum_other_doc_count ?? 0);

    acc[cfg.queryKey!] = {
      kind: "terms",
      valuesAndCounts,
      selectedValue: selectedFacets[cfg.queryKey!] ?? [],
      totalFacetCounts,
      title: cfg.title,
    };

    return acc;
  }

  // RANGE FACETS (min/max)
  if (cfg.type === "range") {
    if (!hasMinMax(data)) return acc;

    const gteKey = `${cfg.field}.gte`;
    const lteKey = `${cfg.field}.lte`;

    acc[cfg.field!] = {
      kind: "range",
      title: cfg.title,
      field: cfg.field,
      min: data.min,
      max: data.max,
      selectedMin: selectedFacets[gteKey]?.[0] ?? "",
      selectedMax: selectedFacets[lteKey]?.[0] ?? "",
      gteKey,
      lteKey,
    };

    return acc;
  }

  return acc;
}, {} as Record<string, any>);

---
<section class="vf-content | vf-u-grid-example | vf-grid vf-grid__col-5">
  <div class=".vf-u-grid__col--span-3--sm vf-u-grid__col--span-1--lg vf-u-grid__col--span-1--xl">
    <br />
    <div style="display: flex;">        
      <div style="padding-top: 0.4em">
      <svg xmlns="http://www.w3.org/2000/svg" width="1.5em" height="1.5em" viewBox="0 0 16 16">
        <rect width="16" height="16" fill="none" />
        <path fill="currentColor" d="M6 4a1 1 0 1 1-2 0a1 1 0 0 1 2 0M2 4a3 3 0 0 1 3-3h6a3 3 0 1 1 0 6H5a3 3 
          0 0 1-3-3m3-2a2 2 0 1 0 0 4h6a2 2 0 1 0 0-4zm6 10a1 1 0 1 0 0-2a1 1 0 0 0 0 2m-9-1a3 3 0 0 1 3-3h6a3 
          3 0 1 1 0 6H5a3 3 0 0 1-3-3m3-2a2 2 0 1 0 0 4h6a2 2 0 1 0 0-4z" />
        </svg> 
      </div>
      <div><h3> Filter by</h3></div>
    </div>
    <div>
      <form id="facets" method="GET" action={searchPageURL} class="vf-form">
        {Object.entries(facets).map(([id, facet], i) => <>
        <SearchFacet facet={facet} id={id} />
        </>
        )}
        <input type="hidden" name="query" value={query}  />
        <!-- {sortBy && (<input type="hidden" name="sortBy" value={sortBy}  />)}
        {sortOrder && (<input type="hidden" name="sortOrder" value={sortOrder} />)} -->
        
      </form>
    </div>
  </div>
  <div class="vf-u-grid__col--span-1--sm  vf-u-grid__col--span-2--md vf-u-grid__col--span-4--lg vf-u-grid__col--span-4--xl" style="min-width:50%">
    { (query || query === "") && (
      <>
        <section class="vf-content">
          <div class="vf-grid vf-grid__col-3">
            <div class="vf-grid__col--span-2">{query && (<h2>Search results for <a href={`${searchPageURL}?query=${query}`}><strong>{query}</strong></a></h2>)}</div>
            <div></div>
          </div>
          <section>
          <div class="vf-grid vf-grid__col-3">
            <div class="vf-grid__col--span-2" style="display: flex; align-items: center;">
              <span id="paginated-results">
                  {results.length != 0 &&  `${(paginationData.page - 1) * paginationData.page_size + 1} - ${Math.min(paginationData.page * paginationData.page_size, totalResults)} of ${totalResults} results`}
                </span>
              </div>
            {/* 
            <div class="vf-form vf-grid__col--span-1" style="display: flex; align-items: center;" id="sort">
            <label for="sortBy" class="vf-form__label vf-u-type__text-body--3 vf-u-padding--0" style="flex: 2; margin:auto;">Sort by:</label>
            <select name="sortBy" id="sortBy" class="vf-form__select vf-u-type__text-body--5 vf-u-padding--100 vf-u-padding__left--200" style="flex: 5; height: 2.5em">
              <option value="relevance" selected={sortBy === "relevance"} >Relevance</option>
              <option value="accession" selected={sortBy === "accession"} >Accession ID</option>
              <option value="release_date" selected={sortBy === "release_date"}>Release Date</option>
            </select>
            <div class="sort-order-buttons" style="flex: 1">
              <button type="button" data-order="ascending" class={sortOrder === "ascending" || !sortOrder ? "active vf-form__select": "vf-form__select"} >⋀</button>
              <button type="button" data-order="descending" class={sortOrder === "descending" ? "active vf-form__select": "vf-form__select"}>⋁</button>
            </div>
            </div>
            */}
          </div>
          <div id="selected-facets" style="margin-top: 0.5rem; align-items: center;">
            {Object.entries(facets).map(([facetKey, facet]) => (
              <SearchSelectedFacet
                key={facetKey}
                selectedList={facet.selectedValue}
                url={searchPageURL}
                text={facet.title}
                query={query}
                selectedFacets={selectedFacets}
                kind={facet.kind}
                minVal={facet?.selectedMin || ""} 
                maxVal={facet?.selectedMax || ""}
              />
            ))}
          </div>
          <div class="vf-card-container | vf-card-container__col-4 | vf-u-fullbleed"  style="--vf-card__image--aspect-ratio: 16 / 9;">
            <div class="vf-card-container__inner">
            {results.length === 0 ? (
              <p>No results found.</p>
            ) : (
              results.map((item) => (
                searchType === "study"? (<StudyCard study={item._source} studyPageRoot="study" />):
                (<ImageCard image={item._source} imagePageRoot="image" />)
                
              ))
            )}
            </div>
            {results.length != 0 && (<br/><PaginationControl  paginationData={paginationData}/>)}
          </div>
          </section>
        </section>
      </>
    )}
  </div>
</section>
<script type="module">
  window.addEventListener('pageshow', (event) => {
    if (event.persisted || performance.getEntriesByType('navigation')[0]?.type === 'back_forward') {
      // Reload the page to reset all state
      window.location.reload();
    }
  });
  // const sortSelect = document.getElementById('sortBy');
  // sortSelect.addEventListener('change', (event) => {
  //   const sortBy = event.target.value;
  //   const url = new URL(window.location.href);
  //   url.searchParams.set('sortBy', sortBy);
  //   window.location.href = url.toString();
  // });

  // document.querySelectorAll('.sort-order-buttons button').forEach(btn => {
  // btn.addEventListener('click', () => {
  //   document.querySelectorAll('.sort-order-buttons button').forEach(b => b.classList.remove('active'));
  //   btn.classList.add('active');
  //   const sortOrder = btn.dataset.order;
  //   const url = new URL(window.location.href);
  //   url.searchParams.set('sortOrder', sortOrder);
  //   window.location.href = url.toString();
  // });
  // });
</script>
<!-- <style>
#sort {
  position: relative;
}
  
#sort select {
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  background: white;
}

#sort::after {
  content: "⋁"; /* your symbol here */
  position: absolute;
  right: 5rem;
  top: 50%;
  transform: translateY(-50%);
  pointer-events: none; /* don’t block clicks */
  font-size: 1.25rem;
  color: #555;
}

.sort-order-buttons {
  margin-left: 0.5em;
  display: inline-flex;
  background: white;
  height: 2.2em;
}

.sort-order-buttons button {
  background: white;
  display: block;
  padding: 0 0.5rem;
}

.sort-order-buttons button:hover {
  background: #e2e2e2;
}

.sort-order-buttons button.active {
  background: #3b6fb6;
  color: white;
  border-color: #3b6fb6;
}
</style> -->

<script type="module">
  function pct(v, min, max) {
    return ((v - min) / (max - min)) * 100;
  }

  function syncSlider(container, from) {
    const minEl = container.querySelector(".range-min");
    const maxEl = container.querySelector(".range-max");
    const progress = container.querySelector(".range-progress");
    const gte = container.closest(".range-facet")?.querySelector(".range-gte");
    const lte = container.closest(".range-facet")?.querySelector(".range-lte");

    if (!minEl || !maxEl || !progress || !gte || !lte) return;

    const minBound = Number(container.dataset.min);
    const maxBound = Number(container.dataset.max);

    let a = Number(minEl.value);
    let b = Number(maxEl.value);

    // prevent crossing
    if (a > b) {
      if (from === "min") {
        a = b;
        minEl.value = String(a);
      } else {
        b = a;
        maxEl.value = String(b);
      }
    }

    const left = pct(a, minBound, maxBound);
    const right = pct(b, minBound, maxBound);
    progress.style.left = left + "%";
    progress.style.width = (right - left) + "%";


    // Only "apply" filter after user changes slider
    container.dataset.dirty = "1";


    const hadInitial = gte.dataset.initial === "1" || lte.dataset.initial === "1";

    if (from !== "init" || hadInitial) {
      gte.value = String(a);
      lte.value = String(b);
    }


    gte.disabled = gte.value === "";
    lte.disabled = lte.value === "";

    // OPTIONAL: if user sets full range, clear (means “no filter”)
    if (a === minBound && b === maxBound) {
      gte.value = "";
      lte.value = "";
      gte.disabled = true;
      lte.disabled = true;
      container.dataset.dirty = "0";
    }
  }

  // init all sliders on page
  document.querySelectorAll(".range-slider").forEach((container) => {
    // if URL already had values, hidden inputs will already be non-empty
    // we still need to draw progress bar
    syncSlider(container, "init");

    const minEl = container.querySelector(".range-min");
    const maxEl = container.querySelector(".range-max");
    minEl?.addEventListener("input", () => syncSlider(container, "min"));
    maxEl?.addEventListener("input", () => syncSlider(container, "max"));

    const form = document.getElementById("facets");
    minEl?.addEventListener("change", () => form?.requestSubmit?.() ?? form?.submit());
    maxEl?.addEventListener("change", () => form?.requestSubmit?.() ?? form?.submit());
  });
</script>