---
import StudyCard from '../../components/cards/BrowseStudyCard.astro';
import ImageCard from '../../components/cards/BrowseImageCard.astro';
import SearchFacet from './SearchFacet.astro';
import SearchSelectedFacet from './SearchSelectedFacet.astro';
import PaginationControl from '../PaginationControl.astro';
import  "../../styles/toggle.css"
import "../../styles/browse_controls.css"
import "../../styles/filter_cards.css"
import { generateParamString } from "../SharedJSFunctions.js"
import {type SelectedFacets, type SearchHits, type FacetData, type PaginationData} from "./SearchInterface.astro"
import SearchResultsTable  from "./SearchResultsTable.astro"
import SearchResultsCompactCards  from "./SearchCompactCards.astro"
import { PUBLIC_SEARCH_API } from "astro:env/client";

const { url, query, searchType} =
  Astro.props as {
    url: URL;
    query: string;
    searchType: string;
  };

const searchEndpoint = searchType === "study"? `${PUBLIC_SEARCH_API}/search/fts`: `${PUBLIC_SEARCH_API}/search/fts/image`;
const searchPageURL = searchType === "study"? "/bioimage-archive/studies": "/bioimage-archive/images";
const sortBy = url.searchParams.get('sortBy');
const sortOrder = url.searchParams.get('sortOrder');
const page = Number(url.searchParams.get('pagination.page')) || 1;
const pageSize = Number(url.searchParams.get('pagination.page_size')) || 12;

const selectedFacets: SelectedFacets = {
  "facet.organism": url.searchParams.getAll("facet.organism"),
  "facet.imaging_method": url.searchParams.getAll("facet.imaging_method"),
  "facet.year": url.searchParams.getAll("facet.year"),
  "facet.annotation_type": url.searchParams.getAll("facet.annotation_type"),

  "facet.image_format": url.searchParams.getAll("facet.image_format"),
  "size_c.eq": url.searchParams.getAll("size_c.eq"),

  // NEW: range filters (store as single-value arrays for compatibility)
  "size_x.gte": url.searchParams.getAll("size_x.gte"),
  "size_x.lte": url.searchParams.getAll("size_x.lte"),

  "size_y.gte": url.searchParams.getAll("size_y.gte"),
  "size_y.lte": url.searchParams.getAll("size_y.lte"),

  "size_z.gte": url.searchParams.getAll("size_z.gte"),
  "size_z.lte": url.searchParams.getAll("size_z.lte"),


  "size_t.gte": url.searchParams.getAll("size_t.gte"),
  "size_t.lte": url.searchParams.getAll("size_t.lte"),

  "total_size_in_bytes.gte": url.searchParams.getAll("total_size_in_bytes.gte"),
  "total_size_in_bytes.lte": url.searchParams.getAll("total_size_in_bytes.lte"),

  "total_physical_size_x.gte": url.searchParams.getAll("total_physical_size_x.gte"),
  "total_physical_size_x.lte": url.searchParams.getAll("total_physical_size_x.lte"),

  "total_physical_size_y.gte": url.searchParams.getAll("total_physical_size_y.gte"),
  "total_physical_size_y.lte": url.searchParams.getAll("total_physical_size_y.lte"),

  "total_physical_size_z.gte": url.searchParams.getAll("total_physical_size_z.gte"),
  "total_physical_size_z.lte": url.searchParams.getAll("total_physical_size_z.lte"),

  "voxel_physical_size_x.gte": url.searchParams.getAll("voxel_physical_size_x.gte"),
  "voxel_physical_size_x.lte": url.searchParams.getAll("voxel_physical_size_x.lte"),

  "voxel_physical_size_y.gte": url.searchParams.getAll("voxel_physical_size_y.gte"),
  "voxel_physical_size_y.lte": url.searchParams.getAll("voxel_physical_size_y.lte"),

  "voxel_physical_size_z.gte": url.searchParams.getAll("voxel_physical_size_z.gte"),
  "voxel_physical_size_z.lte": url.searchParams.getAll("voxel_physical_size_z.lte"),
};

let hits = {} as SearchHits;
let facetData = {} as FacetData;
let paginationData = {} as PaginationData;

const hasQueryParam = query || query ==="";
if (hasQueryParam) {
  const searchURL = generateParamString(
    searchEndpoint,
    query,
    page,
    selectedFacets,
    pageSize
  );

  const res = await fetch(searchURL);
  if (res.ok) {
    const data = await res.json();
    hits = data.hits;
    facetData = data.facets;
    paginationData = data.pagination;
  }
}


const totalResults = hits?.total?.value ?? 0;
let results;

// Sorting on Server side till the API can sort results.

function parseAccession(id) {
    const match = id.match(/^([A-Z\-]+)(\d+)$/i);
    if (!match) return [id, 0];
    return [match[1], parseInt(match[2], 10)];
  }

function sortAcession(aId, bId, sortOrder){
  const [aPrefix, aNum] = parseAccession(aId);
      const [bPrefix, bNum] = parseAccession(bId);
      const prefixCompare = aPrefix.localeCompare(bPrefix);
      if (prefixCompare !== 0) return sortOrder === 'descending' ? -prefixCompare : prefixCompare;
      return sortOrder === 'descending' ? bNum - aNum : aNum - bNum;
}

function sortReleaseDate(aReleaseDate, bReleaseDate, sortOrder){
  const aTime = new Date(aReleaseDate).getTime();
  const bTime = new Date(bReleaseDate).getTime();
  return sortOrder === 'descending' ? bTime - aTime : aTime - bTime
}

switch(sortBy) {
  // case "relevance":
  //   results = sortOrder === "descending"? hits.hits.reverse() : hits.hits;
  //   break;
  // case "accession":
  //   results = hits.hits.sort((a, b) => {return sortAcession(a?._source?.accession_id, b?._source?.accession_id, sortOrder)});
  //   break;
  // case "release_date":
  //   results = hits.hits.sort(function(a,b){ return sortReleaseDate(a?._source?.release_date, b?._source?.release_date, sortOrder)});
  //   break;
  default:
    results = hits.hits;
    break;
}

function hasBuckets(x: any): x is FacetData {
  return !!x && Array.isArray(x.buckets);
}

function hasMinMax(x: any): x is { min: number; max: number; globalMin: number; globalMax: number; globalCount: number } {
  return !!x && typeof x.globalMin === "number" && typeof x.globalMax === "number";
}


const FACET_CONFIG: Record<
  string,
  { title: string; type: "terms" | "range" | "slider"; queryKey?: string; field?: string }
> = {
  scientific_name: { title: "Organism", type: "terms", queryKey: "facet.organism" },
  imaging_method: { title: "Imaging Method", type: "terms", queryKey: "facet.imaging_method" },
  release_date: { title: "Release Year", type: "terms", queryKey: "facet.year" },
  annotation_type: { title: "Annotation Method", type: "terms", queryKey: "facet.annotation_type" },

  image_format: { title: "Image Format", type: "terms", queryKey: "facet.image_format" },
  number_of_channels: { title: "Channels", type: "terms", queryKey: "size_c.eq" },

  z_planes: { title: "Z-Planes", type: "slider", field: "size_z" },
  image_pixel_x: { title: "Image Pixel X (px)", type: "slider", field: "size_x" },
  image_pixel_y: { title: "Image Pixel Y (px)", type: "slider", field: "size_y" },
  time_steps: { title: "Time Steps", type: "slider", field: "size_t" },
  total_size_in_bytes: { title: "Total Size (bytes)", type: "slider", field: "total_size_in_bytes" },
  total_physical_size_x: { title: "Total Physical Size X (m)", type: "range", field: "total_physical_size_x" },
  total_physical_size_y: { title: "Total Physical Size Y (m)", type: "range", field: "total_physical_size_y" },
  total_physical_size_z: { title: "Total Physical Size Z (m)", type: "range", field: "total_physical_size_z" },
  voxel_physical_size_x: { title: "Voxel Physical Size X (m/px)", type: "range", field: "voxel_physical_size_x" },
  voxel_physical_size_y: { title: "Voxel Physical Size Y (m/px)", type: "range", field: "voxel_physical_size_y" },
  voxel_physical_size_z: { title: "Voxel Physical Size Z (m/px)", type: "range", field: "voxel_physical_size_z" },


};

const facets = Object.entries(facetData).reduce((acc, [facetKey, data]) => {
  const cfg = FACET_CONFIG[facetKey];
  if (!cfg) return acc;

  // TERMS FACETS (buckets)
  if (cfg.type === "terms") {
    if (!hasBuckets(data)) return acc;

    const valuesAndCounts = data.buckets
      .slice()
      .sort((a, b) => {
        const aKey = (a.key_as_string ?? a.key ?? "").toString().toLowerCase();
        const bKey = (b.key_as_string ?? b.key ?? "").toString().toLowerCase();
        return aKey.localeCompare(bKey);
      })
      .reduce((obj, bucket) => {
        const k = (bucket.key_as_string ?? bucket.key ?? "").toString();
        obj[k] = bucket.doc_count;
        return obj;
      }, {} as Record<string, number>);

    const totalFacetCounts =
      Object.keys(valuesAndCounts).length + (data.sum_other_doc_count ?? 0);

    acc[cfg.queryKey!] = {
      kind: "terms",
      valuesAndCounts,
      selectedValue: selectedFacets[cfg.queryKey!] ?? [],
      totalFacetCounts,
      title: cfg.title,
    };

    return acc;
  }

  // RANGE FACETS (min/max)
  if (cfg.type === "range" || cfg.type === "slider") {
    if (!hasMinMax(data)) return acc;

    const gteKey = `${cfg.field}.gte`;
    const lteKey = `${cfg.field}.lte`;

    acc[cfg.field!] = {
      kind: cfg.type,
      title: cfg.title,
      field: cfg.field,
      min: data.min,
      max: data.max,
      globalMin: data.globalMin,
      globalMax: data.globalMax,
      globalCount: data.globalCount,
      selectedMin: selectedFacets[gteKey]?.[0] ?? "",
      selectedMax: selectedFacets[lteKey]?.[0] ?? "",
      gteKey,
      lteKey,
    };

    return acc;
  }

  return acc;
}, {} as Record<string, any>);
---
<style>
.toggle-switch {
    display: inline-flex;
    background: #f0f0f0;
    padding: 4px;
    border-radius: 20px;
}
.toggle-option {
    position: relative;
    cursor: pointer;
}
.toggle-option input {
    position: absolute;
    opacity: 0;
    cursor: pointer;
}
.toggle-label {
    display: inline-block;
    padding: 8px 16px;
    border-radius: 16px;
    transition: all 0.3s ease;
}
.toggle-option input:checked + .toggle-label {
    background: #3b6fb6;
    color: white;
}
.toggle-option:hover input:not(:checked) + .toggle-label {
    background: #e0e0e0;
}
.controls-inner {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 0.5em;
    margin: 0 auto;
}
 .controls-container {
  position: sticky;
  top: 0;
  background: white;
  padding: 1em;
  box-shadow: 0 0px 0px;
}

.column-toggle-container {
    text-align: center;
    padding: 0.5em;
}
.column-toggle {
    display: inline-flex;
    background: #f0f0f0;
    padding: 4px;
    border-radius: 20px;
    gap: 4px;
    margin-bottom: 1em;
}
.column-option {
    position: relative;
    cursor: pointer;
}
.column-option input {
    position: absolute;
    opacity: 0;
    cursor: pointer;
}
.column-label {
    display: inline-block;
    padding: 4px 12px;
    border-radius: 16px;
    transition: all 0.3s ease;
    font-size: 0.9em;
}
.column-option input:checked + .column-label {
    background: #3b6fb6;
    color: white;
}
.column-option:hover input:not(:checked) + .column-label {
    background: #e0e0e0;
}

.grid-container {
    background-color: var(--vf-u-background-color-ui--white);
    width: 100%;
    padding: 0 1rem;
}
.grid-inner {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 0.25rem;
    max-width: var(--vf-content-max-width, 1200px);
    margin: 0 auto;
}
</style>

<script type="module">
  window.addEventListener('pageshow', (event) => {
    if (event.persisted || performance.getEntriesByType('navigation')[0]?.type === 'back_forward') {
      // Reload the page to reset all state
      window.location.reload();
    }
  });
  const pagination = document.getElementById('pageSize');
   pagination.addEventListener('change', (event) => {
     const pageSize = event.target.value;
     const url = new URL(window.location.href);
     url.searchParams.set('pagination.page_size', pageSize);
     window.location.href = url.toString();
   });
  function formatBytesToHumanSize(sizeBytes) {
    var i = sizeBytes == 0 ? 0 : Math.floor(Math.log(sizeBytes) / Math.log(1000));
    return `${Number(sizeBytes / Math.pow(1000, i)).toFixed(2)} ${['B', 'kB', 'MB', 'GB', 'TB', 'PB'][i]}`
}

  function pct(v, min, max) {
    return ((v - min) / (max - min)) * 100;
  }

  function syncSlider(container, from) {
    const minEl = container.querySelector(".slider-min");
    const maxEl = container.querySelector(".slider-max");
    const progress = container.querySelector(".slider-progress");
    const label = container.closest(".slider-facet")?.querySelector(".slider-label");
    const gte = container.closest(".slider-facet")?.querySelector(".slider-gte");
    const lte = container.closest(".slider-facet")?.querySelector(".slider-lte");
    
    if (!minEl || !maxEl || !progress || !gte || !lte) return;

    const minBound = Number(container.dataset.min);
    const maxBound = Number(container.dataset.max);

    let a = Number(minEl.value);
    let b = Number(maxEl.value);

    // prevent crossing
    if (a > b) {
      if (from === "min") {
        a = b;
        minEl.value = String(a);
      } else {
        b = a;
        maxEl.value = String(b);
      }
    }

    const left = pct(a, minBound, maxBound);
    const right = pct(b, minBound, maxBound);
    progress.style.left = left + "%";
    progress.style.width = (right - left) + "%";

    if (label.classList.contains("total_size_in_bytes")) {
      label.textContent = `${formatBytesToHumanSize(a)} – ${formatBytesToHumanSize(b)}`;
    }else{
      label.textContent = `${Math.floor(a)} – ${Math.ceil(b)}`;
    }

    container.dataset.dirty = "1";


    const hadInitial = gte.dataset.initial === "1" || lte.dataset.initial === "1";

    if (from !== "init" || hadInitial) {
      gte.value = String(a);
      lte.value = String(b);
    }


    gte.disabled = gte.value === "";
    lte.disabled = lte.value === "";


    if (a === minBound && b === maxBound) {
      gte.value = "";
      lte.value = "";
      gte.disabled = true;
      lte.disabled = true;
      container.dataset.dirty = "0";
      if (label.classList.contains("total_size_in_bytes")) {
        label.textContent = label.dataset.default ?? `${formatBytesToHumanSize(a)} – ${formatBytesToHumanSize(b)}`;
      }else{
        label.textContent = label.dataset.default ?? `${Math.floor(minBound)} – ${Math.ceil(maxBound)}`;
      }
      
    }
  }


  document.querySelectorAll(".slider-slider").forEach((container) => {
    // if URL already had values, hidden inputs will already be non-empty
    // we still need to draw progress bar
    syncSlider(container, "init");

    const minEl = container.querySelector(".slider-min");
    const maxEl = container.querySelector(".slider-max");
    minEl?.addEventListener("input", () => syncSlider(container, "min"));
    maxEl?.addEventListener("input", () => syncSlider(container, "max"));

    const form = document.getElementById("facets");
    minEl?.addEventListener("change", () => form?.requestSubmit?.() ?? form?.submit());
    maxEl?.addEventListener("change", () => form?.requestSubmit?.() ?? form?.submit());
  });

  function clamp(n, lo, hi) {
    if (!Number.isFinite(n)) return NaN;
    return Math.min(hi, Math.max(lo, n));
  }

  function getForm() {
    return document.getElementById("facets");
  }

  function syncNames() {
      const gHas = gte.value.trim() !== "";
      const lHas = lte.value.trim() !== "";

      if (gHas) gte.setAttribute("name", gte.dataset.name);
      else gte.removeAttribute("name");

      if (lHas) lte.setAttribute("name", lte.dataset.name);
      else lte.removeAttribute("name");
    }

  function submitFacets() {
    const form = getForm();
    if (!form) return;
    // Ensure empty fields have no name before submission
    form.querySelectorAll("input[data-name]").forEach((el) => {
      if (el.value.trim() === "") el.removeAttribute("name");
      else el.setAttribute("name", el.dataset.name);
    });
    form.requestSubmit?.() ?? form.submit();
  }

  function initRangeFacet(fieldset) {
    const gte = fieldset.querySelector('input.range-gte[type="number"]');
    const lte = fieldset.querySelector('input.range-lte[type="number"]');
    const gteHidden = fieldset.querySelector('input.range-gte-hidden[type="hidden"]');
    const lteHidden = fieldset.querySelector('input.range-lte-hidden[type="hidden"]');
    if (!gte || !lte || !gteHidden || !lteHidden) return;

    const minBound = Number(gte.min);
    const maxBound = Number(gte.max);

    let debounceTimer = null;
    const DEBOUNCE_MS = 1500;

    function commit(from) {
      const rawA = gte.value === "" ? NaN : Number(gte.value);
      const rawB = lte.value === "" ? NaN : Number(lte.value);

      let a = clamp(rawA, minBound, maxBound);
      let b = clamp(rawB, minBound, maxBound);

      // auto-fill other side (optional)
      if (from === "gte" && Number.isFinite(a) && !Number.isFinite(b)) {
        b = maxBound;
        lte.value = String(b);
      }
      if (from === "lte" && Number.isFinite(b) && !Number.isFinite(a)) {
        a = minBound;
        gte.value = String(a);
      }

      // prevent crossing
      if (Number.isFinite(a) && Number.isFinite(b) && a > b) {
        if (from === "gte") {
          a = b;
          gte.value = String(a);
        } else {
          b = a;
          lte.value = String(b);
        }
      }

      // ✅ Only submit via hidden inputs; disable if empty
      if (Number.isFinite(a)) {
        gteHidden.value = String(a);
        gteHidden.disabled = false;
      } else {
        gteHidden.value = "";
        gteHidden.disabled = true;
      }

      if (Number.isFinite(b)) {
        lteHidden.value = String(b);
        lteHidden.disabled = false;
      } else {
        lteHidden.value = "";
        lteHidden.disabled = true;
      }

      submitFacets();
    }

    function debounceCommit(from) {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => commit(from), DEBOUNCE_MS);
    }

    gte.addEventListener("input", () => debounceCommit("gte"));
    lte.addEventListener("input", () => debounceCommit("lte"));
    gte.addEventListener("blur", () => commit("gte"));
    lte.addEventListener("blur", () => commit("lte"));

    // Enter = apply immediately
    gte.addEventListener("keydown", (e) => { if (e.key === "Enter") { e.preventDefault(); commit("gte"); }});
    lte.addEventListener("keydown", (e) => { if (e.key === "Enter") { e.preventDefault(); commit("lte"); }});
  }

  document.querySelectorAll("fieldset.range-facet").forEach(initRangeFacet);
  document.querySelectorAll("fieldset.range-facet").forEach(initRangeFacet);

    function toggleView(viewId) {
        const views = ['card-view', 'table-view', 'grid-view'];
        views.forEach(id => {
            document.getElementById(id).style.display = id === viewId ? 'block' : 'none';
        });
        
        if (viewId === 'table-view') {
            dataTable?.columns.adjust();
        }
  }
  document.addEventListener('DOMContentLoaded', () => {
        // Add event listeners for view toggles
        document.querySelectorAll('input[name="view"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                if (e.target.checked) {
                    toggleView(e.target.value);
                }
            });
        });

  window.setGridColumns = function(columns) {
    const gridInner = document.querySelector('.grid-inner');
    if (gridInner) {
        gridInner.style.gridTemplateColumns = `repeat(${columns}, 1fr)`;
        
        // Get all size bars and cube wrappers
        const sizeBars = document.querySelectorAll('.compact-size-bar');
        const icons = document.querySelectorAll('.icon-container');
        
        // Show/hide based on column count
        const display = columns === 5 ? 'none' : '';
        sizeBars.forEach(bar => bar.style.display = display);
        icons.forEach(icon => icon.style.display = display);
    }
  }
  // Set initial grid columns
  setGridColumns(4);
  });
</script>

<section class="vf-content | vf-u-grid-example | vf-grid vf-grid__col-5">
  <div class="vf-u-grid__col--span-3--sm vf-u-grid__col--span-1--lg vf-u-grid__col--span-1--xl">
    <br />
    <div style="display: flex;">        
      <div style="padding-top: 0.4em">
      <svg xmlns="http://www.w3.org/2000/svg" width="1.5em" height="1.5em" viewBox="0 0 16 16">
        <rect width="16" height="16" fill="none" />
        <path fill="currentColor" d="M6 4a1 1 0 1 1-2 0a1 1 0 0 1 2 0M2 4a3 3 0 0 1 3-3h6a3 3 0 1 1 0 6H5a3 3 
          0 0 1-3-3m3-2a2 2 0 1 0 0 4h6a2 2 0 1 0 0-4zm6 10a1 1 0 1 0 0-2a1 1 0 0 0 0 2m-9-1a3 3 0 0 1 3-3h6a3 
          3 0 1 1 0 6H5a3 3 0 0 1-3-3m3-2a2 2 0 1 0 0 4h6a2 2 0 1 0 0-4z" />
        </svg> 
      </div>
      <div><h3> Filter by</h3></div>
    </div>
    <div>
      <form id="facets" method="GET" action={searchPageURL} class="vf-form">
        {Object.entries(facets).map(([id, facet], i) => <>
        <SearchFacet facet={facet} id={id} />
        </>
        )}
        <input type="hidden" name="query" value={query}  />        
      </form>
    </div>
  </div>
  <div class="vf-u-grid__col--span-1--sm  vf-u-grid__col--span-2--md vf-u-grid__col--span-4--lg vf-u-grid__col--span-4--xl" style="min-width:50%">
    { (hasQueryParam) && (
        <section class="vf-content">
          <div class="vf-grid vf-grid__col-3">
            <div class="vf-grid__col--span-2">{query && (<h2>Search results for <a href={`${searchPageURL}?query=${query}`}><strong>{query}</strong></a></h2>)}</div>
            <div></div>
          </div>
          <section class="vf-content">
            <div class="vf-grid vf-grid__col-5">
              <div class="vf-u-grid__col--span-1--sm  vf-u-grid__col--span-2--md vf-u-grid__col--span-4--lg vf-u-grid__col--span-4--xl" style="display: flex; align-items: center;">
                <span id="paginated-results">
                    {results.length != 0 &&  `${(paginationData.page - 1) * paginationData.page_size + 1} - ${Math.min(paginationData.page * paginationData.page_size, totalResults)} of ${totalResults} results`}
                  </span>
                </div>
                <div class="vf-form vf-u-grid__col--span-1--sm  vf-u-grid__col--span-1--md vf-u-grid__col--span-1--lg vf-u-grid__col--span-1--xl" style="display: flex; align-items: center; justify-content: flex-end; gap: 0.5rem;white-space: nowrap;" id="pageSizeDiv">
                  <div class="controls-container">
                    <div class="controls-inner">
                      <div class="toggle-switch">
                        <label class="toggle-option">
                            <input type="radio" name="view" value="card-view" checked>
                            <span class="toggle-label">Cards</span>
                        </label>
                        <label class="toggle-option">
                            <input type="radio" name="view" value="table-view">
                            <span class="toggle-label">Table</span>
                        </label>
                        <label class="toggle-option">
                            <input type="radio" name="view" value="grid-view">
                            <span class="toggle-label">Grid</span>
                        </label>
                      </div>
                    </div>
                  </div>
                  <label for="pageSize" class="vf-form__label vf-u-type__text-body--4 vf-u-padding--100" style="margin: 0;padding: 0;border: 0;">Page Size:</label>
                  <select name="pageSize" id="pageSize" class="vf-form__select vf-u-type__text-body--5 vf-u-padding--100" style="height: 2.5em;width: auto;min-width: 8rem;">
                    <option value="12" selected={pageSize === 12} >Default</option>
                    <option value="30" selected={pageSize === 30} >30</option>
                    <option value="60" selected={pageSize === 60} >60</option>
                    <option value="90" selected={pageSize === 90}>90</option>
                  </select>
                  
                </div>
            </div>
            <div id="selected-facets" style="margin-top: 0.5rem; align-items: center;">
              <SearchSelectedFacet query={query} url={searchPageURL} text="Query" kind="query" />
              {Object.entries(facets).map(([facetKey, facet]) => (
                <SearchSelectedFacet
                  key={facetKey}
                  selectedList={facet.selectedValue}
                  url={searchPageURL}
                  text={facet.title}
                  query={query}
                  selectedFacets={selectedFacets}
                  kind={facet.kind}
                  minVal={facet?.selectedMin || ""} 
                  maxVal={facet?.selectedMax || ""}
                  pageSize={pageSize}
                />
              ))}
            </div>
            <div id="card-view">
            <div class="vf-card-container vf-card-container__col-4 vf-u-fullbleed"  style="--vf-card__image--aspect-ratio: 16 / 9; --vf-card-container__inner--grid-gap: 0.5rem;">
              <div class="vf-card-container__inner">
              {results.length === 0 ? (
                <p>No results found.</p>
              ) : (
                results.map((item) => (
                  searchType === "study"? (<StudyCard study={item._source} studyPageRoot="study" />):
                  (<ImageCard image={item._source} imagePageRoot="image" />)
                  
                ))
              )}
              </div>
            </div>
            </div>
            <div id="table-view" style="display: none;">
              <SearchResultsTable results={results} resultType={searchType}/>
            </div>
            <div id="grid-view" style="display: none;">
              <div class="column-toggle-container">
                <div class="column-toggle">
                    <label class="column-option">
                        <input type="radio" name="columns" value="3" onchange="setGridColumns(3)">
                        <span class="column-label">3 Columns</span>
                    </label>
                    <label class="column-option">
                        <input type="radio" name="columns" value="4" checked onchange="setGridColumns(4)">
                        <span class="column-label">4 Columns</span>
                    </label>
                    <label class="column-option">
                        <input type="radio" name="columns" value="5" onchange="setGridColumns(5)">
                        <span class="column-label">5 Columns</span>
                    </label>
                </div>
              </div>
              <section class="grid-container">
                  <div class="grid-inner">
                    {results.length === 0 ? (
                      <p>No results found.</p>
                    ) : (
                      results.map((item) => (
                        <SearchResultsCompactCards result={item._source} resultType={searchType}/>
                      ))
                    )}
                  </div>
              </section>
            </div>
            {results.length != 0 && (<br/><PaginationControl  paginationData={paginationData}/>)}
          </section>
        </section>
      )
    }
  </div>
</section>